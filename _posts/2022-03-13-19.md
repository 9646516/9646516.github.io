---
layout: post
title: "树"
categories:
  - Category
---

花了几天时间复习了下各种树。树的种类繁多，目标都很一致，即保持二叉搜索的性质的同时保证树高不要太高。有一些树引入了其他操作(如分裂、合并)的话，这些树并不是那么平衡，树要高一些。树和树之间都有不同的取舍，应该根据目标选择合适的树。

首先说说如何保持树高。AVL通过简单的约束子树树高相近保证了不会出现一个大子树和一个小子树的情况，这使得数据分布较为均衡。红黑树首先通过黑高相同保证黑高是log级别的，然后不允许连续两个红节点和插入的节点都是红色的两个性质让树高和黑高是线性关系。Treap的思路是，一个BST可以有多个形态，如果随机选一个形态，大概率不会选到链状的。Splay则是通过Splay操作中顺带折叠了LL和RR的情况，这一步设计的非常巧妙。

然后说下实现，其实AVL、Splay、Treap都很好写，AVL可能复杂一点但是都属于能一口气写完的那种。红黑树的性质太多了，旋转不直观同时还涉及给NIL找爸爸的问题，写了一次之后不会再写第二次了。

之后说下如何理解平衡树。简单的说是，所有的平衡树都只有两种操作，左旋和右旋。旋转不会改变树的中序遍历，但是会改变树的性质(平衡因子、黑高)。不同的树维护的其实不是中序遍历，而是树的性质。AVL是把高的树转上去，降低平衡因子的绝对值。红黑树是把多余的黑色向上传递，直到遇到红色节点消掉多余的黑色或者遇到情况4直接消掉。Treap是在保证偏序的情况下，把要删除的点转到叶子直接删除。

