---
layout: post
title: "探讨一些简单的问题"
categories:
  - Category
---

最短路问题可能是大多数人学的第一个算法，不过就是简单的最短路有很多问题不仔细想想的话，可能也会犯下错误。

---

问题1:

dijkstra有必要写vis数组吗?

答:按照严格的dijkstra定义，每个点只会入队一次，所以才证明得到复杂度是$$O(nlogn)$$或者$$O(nlogm)$$的。但是这个定义导致了dijkstra自身存在缺陷，因此我现在写的最短路都不是严格的dijkstra。

---

问题2:

严格定义的dijkstra的缺陷是？

答:首先严格的dijkstra不能算带负权边的图，回想一下dijkstra是怎么证明的。大意应该是如果不选当前点来松弛，不会使得结果更好。但是带负权边的图不满足这个条件，因此严格的dijkstra是错误的，具体可以考虑以下这个有向图。（以下所有的图的起点都是1，第一行分别是点数和边数）

```
4 5
1 2 1
1 3 0
1 4 99
2 3 1
4 2 -300
```

其次不能跑最长路,原因类似，dijkstra的假设不满足，即从当前最远的点更新不会使得结果更坏的假设是错误的。具体参考以下这个有向图。

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 3
```

反思下这两个错误都是由于一个原因，即证明中的假设是错误的，这个错误的假设会导致一个点在自己不是最优的时候更新其他点，而且由于每个点只会出队一次，导致这个点错过了最佳的更新其他点的时间。

---

问题3：

如何解决dijkstra的以上缺陷？

答:通过上面的分析可以看出，问题的关键在于每个点只会出队一次。所以只要允许每个点出队多次即可。是不是想到了上面似曾相识的东西?这不是SPFA么。确实这么写很像用堆的SPFA，或者说就是用堆的SPFA。

我看了很多国外选手的代码，似乎现在流行的dijkstra都是这么写的了。

---

问题4:允许多次出队的dijkstra是否只是去掉vis数组？

答：否，如果只是去掉vis数组以下代码输出的有向图可以让复杂度达到$$O(m^2)$$。

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n = 200003, m = 300000;
    printf("%d %d\n", n, m);
    for (int i = 2; i <= 100000; i++)
        printf("%d %d %d\n", 1, i, i);
    for (int i = 2; i <= 100000; i++)
        printf("%d %d %d\n", i, 100001, (int)1e9 - 2 * i);
    for (int i = 0; i < 100002; i++)
        printf("%d %d %d\n", 100001, 100002 + i, (int)1e9);
    return 0;
}
```

仔细观察这个图，可以发现问题的根源在于队列中存在同一个点的多个不同状态。之前只允许出队一次的时候，其他的点都不会更新另外的点。但是去掉vis后这个问题就导致进行多次无效更新。

解决办法有两个:

- 向队列插入新的状态的时候删除老的状态
- 只有当前状态距离等于dis[v]的时候才进行更新

如果你用的是优先队列只能采取方法2，如果用的是set/multiset两个都可以用。个人测试下，优先队列的写法可能会好一点，不过这个可能是和具体实现有关。

---

问题5：如果允许多次出队复杂度是多少?

别问，问就是Bellman-Ford的复杂度乘上堆操作的复杂度。

但是如果负权图或者最长路真的卡这种写法的话，只能试试各种玄学优化的SPFA了。

