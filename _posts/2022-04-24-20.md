---
layout: post
title: "对C++的一些理解"
categories:
  - Category
---

## 类型转换

C++中对象和指针的转换是不同的。原因很简单，对象在编译的时候就知道大小，而且不能运行时变动，这使得情况会简单很多。

对象的类型转换中大多数涉及具体的指令，特殊情况有const_cast,reinterpret_cast以及一些特殊的static_cast。

指针的转换如果转换前后的underlying value相同，则不涉及具体指令。

如果有虚表，则会在运行时查虚表得到自己的真实类型，然后再根据编译时留下的信息调整地址。一般来说，如果是单继承，并且编译器把基类放在内存块开头的话，基类指针和派生指针的地址也是相同的，如果优化到位的话，应该也不会产生具体指令的。但是如果是多继承的话，从第二个基类开始就会产生查表并且改变指针地址的行为。

## 虚拟机制

虚拟机制可能是C++最烦人的机制之一了。从现在来看，如果使用虚拟机制，最好是单继承，或者基类没有成员，并且不要使用虚拟继承，不然会产生非常严重的性能问题。

首先C++只有堆上的对象有虚拟机制，栈上的对象由于前述原因并没有虚拟机制，编译的时候直接静态链接到对应的函数上。

C++标准里面没有说到底应该怎么实现虚拟机制，因此虚表的机制只是一种大家都用的实现。

虚表是编译期生成的，一个类至少有一张虚表，由于编译器的实现不同，同一个虚函数可能有不同的版本，这些不同版本往往只是有细微的差别，如是否初始化和是否调整this指针等。如果使用多继承的话可能会出现很多同一个类的不同虚表，当然这也和具体实现有关。

堆上对象的虚指针是在运行的时候填进去的，具体时间是在基类构造完成之后。此时就有一个问题，如果是多继承，那么是构造完成一个填一个，还是全部构造完成再全部填上。我在MSVC上测试是构造完成一个填一个。不过无论如何在构造函数的用户代码部分，虚表一定是已经填完了，所以在用户代码的部分使用虚函数是没问题的。但是在初始化列表中使用虚函数就会有虚表是否填好的问题。当然编译器自己会有优化，如果在构造函数中使用虚函数，会直接静态链接到对应函数，因为标准保证了构造函数中访问的一定是自己的虚函数，这使得编译器有权限直接静态链接，如以下代码大概率是没问题的。

```cpp
struct P {
    virtual int F1() { return 1; }
};

struct Q {
    Q(int) {}
};

struct Z : Q, P {
    Z() : Q(F1()) {}
};

int main() {
    Z z;
    return 0;
}
```

但是，如果初始化列表中调用的不是虚函数，而是一个普通函数，但是这个函数调用了虚函数。这样的话不能确定F函数中this的类型，所以会使用虚拟机制。以下代码大概率是有问题的。

```cpp
struct P {
    virtual int F1() { return 1; }
};

struct Q {
    Q(int) {}
};

struct Z : Q, P {
    int F() { return F1(); }

    Z() : Q(F()) {}
};

int main() {
    Z z;
    return 0;
}
```

这一切都和编译器的实现有关，而且没有问题不代表写法正确，有可能是编译器的正确行为掩盖了代码的错误，最好不要在初始化列表中使用虚函数。

### 虚拟继承

一句话，虚拟继承我劝你别用。因为能虚拟继承不仅仅自身性能差，它还用到了非空的多继承。

为了保证整个继承树中只有一个虚拟基类，虚拟继承用了和虚表类似的方法，虚拟继承也有自己的虚表，记录了虚拟基类的位置。

虚拟继承为了只构造一次，它只会在构造过程中dfs序最小的地方进行构造，也就是在"most derived"的地方进行。dfs结束的时候才会填写虚表，和之前虚函数一样，不要在初始化列表中使用虚基类的成员，因为此时虚指针还没填。

虚基类的成员的访问都要通过虚指针跳转，如果是虚基类套虚基类(这是人能干出来的事情?)还要跳转多次。而且复制一个有虚基类的对象的时候，虚基类会被复制多次，因为为了防止被多次复制的代价往往更高。

总之虚拟继承性能有大问题，基本没有使用它的理由。

### 对象的大小

以下内容假设在64位机器上运行，指针大小8个字节，强制对8对齐。

C++保证一个类中同一个public/private/protected session中成员的地址按照申明顺序排列，这只保证的相对顺序，不保证真实地址相连。同时不同session的相对顺序也是没有保证的。为了简单起见，以下代码中只有一个session。

在继承过程中每个基类都是完整的，也就是说不会为了紧凑起见，把数据插入到上一个基类padding的地方。原因很简单，

```cpp
struct alignas(8) P {
    int32_t y;
};

struct alignas(8) Q {
    int32_t y;
};

struct alignas(8) Z : P, Q {
};
```

P，Q的大小是8，Z的大小是16。

如果基类有虚函数且派生类有新虚函数，不会在派生类中新建一个虚表，而会合并到子类的虚表中。

```cpp
struct alignas(8) P {
    virtual void F1() {}
};

struct alignas(8) Q {
    virtual void F2() {}
};

struct alignas(8) Z : P, Q {
    virtual void F3() {}
};
```

P，Q的大小是8，Z的大小是16。

```cpp
struct alignas(8) P {
    virtual void F1() {}
};

struct alignas(8) Q : P {
    virtual void F2() {}
};
```

P，Q的大小是8

### 右值引用

C++的右值引用往往被拿来和rust中的移动类比，实际上虽然两者很像，但是最好不要用一种概念理解另外一种。

C++的move函数的名字真的不知道怎么取出来的，误导了无数人。C++中的右值引用只是一个语义上的概念，实际上它什么都不做。move和forward只是一个static_cast，可能根本没有编译到具体的指令。具体的移动过程是在移动拷贝和移动构造函数中完成的。

右值引用其实只是为了和左值引用区分开来而弄出来的概念。右值引用说明这个对象以后没有用了，可以随便处理。左值引用说的是以后这个值可能还要用，因此拷贝和构造的时候只能复制内容。

上面说了具体的移动过程是在移动拷贝和移动构造函数中完成的。因此POD根本没有移动的必要，因为移动了也是复制。
